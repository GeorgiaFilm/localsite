<!DOCTYPE html>
<html lang="en-us">
<head>
<meta charset="utf-8">
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
<title>Data Commons - Timelines</title>
<link rel="shortcut icon" href="data:image/x-icon;," type="image/x-icon">
<meta name="viewport" content="width=device-width, initial-scale=1">

<link type="text/css" href="../css/base.css" rel="stylesheet" id="/localsite/css/base.css" />
<script type="text/javascript" src="../js/localsite.js?showheader=true&showsearch=true&scope=country"></script>

<script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
<script src="../js/earthscape.js" id="/localsite/js/earthscape.js" type="text/javascript"></script>

<script>
loadMarkdown("README.md", "readmeDiv", "_parent");

/* Also update home/index.html */
document.addEventListener('hashChangeEvent', function (elem) {
    console.log("Timeline page detects URL hashChangeEvent");
    let hash = getHash();
    if (!hash.scope) {
        hash.scope = "country"; // CUSTOM - also set in call to localsite.js above.
    }
    if (hash.scope != priorHash.scope || hash.goal != priorHash.goal) {
        const selectScope = document.getElementById("selectScope");
        if (selectScope) {
          selectScope.value = hash.scope;
        }
        updateDcidSelectFromSheet(hash.scope); // In localsite/js/earthscape.js
    }
}, false);
document.addEventListener('DOMContentLoaded', () => {
    let hash = getHash();
    if (!hash.scope) {
        hash.scope = document.getElementById('selectScope').options[document.getElementById('selectScope').selectedIndex].text;
    }
    //alert(hash.scope)
    updateDcidSelectFromSheet(hash.scope);
    
    document.addEventListener('change', function(event) {
        if (event.target.name === 'whichLines') {
          console.log('whichLines changed to ' + event.target.value);
          refreshTimeline();
        }
    });

    document.getElementById('chartVariable').addEventListener('change', (event) => {
        refreshTimeline();
    });

    // State menu change
    document.getElementById('entityId').addEventListener('change', (event) => {
        //entityId = event.target.value;
        refreshTimeline();
     });
    document.querySelectorAll('input[name="whichPer"]').forEach((radio) => {
        radio.addEventListener('change', () => {
            refreshTimeline(); // This will re-fetch emissions and population and update the chart
        });
    });
});
</script>

<style>
#selectScope {
    display: block !important;
}
.heroTransparent {
  position: relative;
  background: linear-gradient(rgba(255, 255, 255, 0.95), rgba(255, 255, 255, 0.95)), 
              url(https://model.earth/apps/img/hero/state/GA/GA-hero.jpg);
  background-size: cover; /* Scales the image to cover the div */
  background-position: center; /* Centers the image in the div */
  background-repeat: no-repeat; /* Prevents the image from repeating */
  height: auto; /* Allow height to be determined by content */
  min-height: 120px; /* Minimum height to show the background image */
}
.contenttoogleChartType {
    display: none;
}
.active {
    display: block;
}
/* Floating legend for timeline chart (fixed viewport position so it doesn't jump around)
    The legend will be fixed in the viewport (top-right by default) regardless of canvas updates.
    Individual legend items remain interactive while the container lets other clicks pass through. */
#div1 { position: relative; }
#floating-legend {
     position: fixed;
     top: 120px;
     right: 20px;
     left: auto;
     background: rgba(255,255,255,0.95);
     border-radius: 8px;
     padding: 8px;
     box-shadow: 0 6px 18px rgba(0,0,0,0.12);
     backdrop-filter: blur(6px);
     border: 1px solid rgba(0,0,0,0.04);
     z-index: 9999;
     min-width: 160px;
     max-height: 320px;
     overflow-y: auto;
     font-size: 13px;
     /* Allow clicks to pass through the legend container so underlying controls (radios, etc.) remain clickable.
         Individual legend items are interactive (see .legend-item pointer-events:auto). */
     pointer-events: none;
}

/* Overlay legend placed inside each chart wrapper (absolute within chart area) */
.overlay-legend {
    position: absolute;
    top: 8px;
    right: 8px;
    background: rgba(255,255,255,0.9);
    border-radius: 6px;
    padding: 6px;
    box-shadow: 0 6px 18px rgba(0,0,0,0.08);
    border: 1px solid rgba(0,0,0,0.04);
    z-index: 10010;
    min-width: 120px;
    max-height: 220px;
    overflow-y: auto;
    font-size: 12px;
    pointer-events: none; /* allow underlying chart interactions except for items */
}
.overlay-legend .overlay-legend-content { pointer-events: auto; }

/* On small screens place legend inside the chart area to avoid overflow */
@media (max-width: 700px) {
    #floating-legend {
        right: auto;
        left: 12px;
        top: 12px;
    }
}
.legend-item { display:flex; align-items:center; gap:8px; padding:6px 8px; margin:4px 0; border-radius:6px; cursor:pointer; transition:all 0.18s ease; 
    /* Make individual items accept pointer events while the container lets other clicks through */
    pointer-events: auto;
}
.legend-item .item-actions { display: none; }
.legend-swatch { width:14px; height:14px; border-radius:3px; box-shadow:0 0 0 1px rgba(0,0,0,0.06) inset; }
.legend-item.hidden { opacity:0.45; }
</style>

<style>
/* Keep the whichLinesHolder controls above the floating legend so radios remain clickable */
/* Ensure per-capita option radios are above the legend (prevents legend items from intercepting clicks) */
#perCapitaOptions { position: relative; z-index: 10002; }
.whichLinesHolder { position: relative; z-index: 10001; }
</style>

<style>
.legend-item:hover { transform: translateY(-1px); box-shadow: 0 8px 20px rgba(0,0,0,0.06); }

</style>


<!-- To remove -->
<style>
/*Table css start */
#table-container {
    padding: 24px 0;
}
#table-container table {
    width: 100%;
    height: auto;
    background-color: transparent;
    border: none;
    font-size: 14px;
    overflow: hidden;
    position: relative;
    text-align: left;
    line-height: 1.55em;
}
#table-container table tr:first-child {
    background-color: #e6e6e6;
    border-bottom: 1px solid #999;
    box-sizing: border-box;
    color: #555;
    font-weight: 700;
    outline: none;
    overflow: hidden;
    position: relative;
    white-space: nowrap;
    width: 100%;
    max-height: 32px;
} 
#table-container table tr:first-child th {
    min-width: 40px;
    width: auto;
    height: 32px;
    background-color: #eee;
    border-right: 1px solid #fff;
    background: #e6e6e6;
    box-sizing: border-box;
    display: inline-flex;
    flex-direction: column;
    justify-content: flex-start;
    overflow: hidden;
    position: relative;
    text-align: left;
    vertical-align: bottom;
}
#table-container table tr:not(:first-child) {
    background-color: #fff;
    color: #333;
    display: inline-block;
    overflow: visible;
    position: relative;
    white-space: nowrap;
}
#table-container table tr:not(:first-child) td {
    border-right: 1px solid #fff;
    border-bottom: 1px solid #ccc;
    box-sizing: border-box;
    display: inline-block;
    outline: none;
    overflow: hidden;
    padding: 4px;
    position: relative;
    text-overflow: ellipsis;
    vertical-align: middle;
    white-space: nowrap;
    font-size: 13px;
    height: 30px;  /*!important;*/
    padding-top: 6px; /*!important;*/
}
#table-container table tr:first-child th.Topic,
#table-container table tr:not(:first-child) td.num0 {
    width: 80px;
}
#table-container table tr:first-child th.Subtopic,
#table-container table tr:not(:first-child) td.num1 {
    width: 80px;
}
#table-container table tr:first-child th.DCID,
#table-container table tr:not(:first-child) td.num2 {
    width: 232px;
}    
#table-container table tr:first-child th.Title,
#table-container table tr:not(:first-child) td.num3 {
    width: 168px;
}
#table-container table tr:first-child th.IsUsable,
#table-container table tr:not(:first-child) td.num4 {
    width: 80px;
}
#table-container table tr:first-child th.Scope,
#table-container table tr:not(:first-child) td.num5 {
    width: 128px;
}
#table-container table tr:first-child th.StartYear,
#table-container table tr:not(:first-child) td.num6 {
    width: 96px;
}
#table-container table tr:first-child th.EndYear,
#table-container table tr:not(:first-child) td.num7 {
    width: 96px;
}
#table-container table tr:first-child th.Source,
#table-container table tr:not(:first-child) td.num8 {
    width: 232px;
}
#table-container table tr:first-child th.Notes,
#table-container table tr:not(:first-child) td.num9 {
    width: 64px;
}
/* Table css end */ 
</style>

</head>

<body>


<div class="heroTransparent notdark">

<div class="content contentpadding large-list">
  <!-- Also update in home repo -->
  <div id="timeline-nav" style="margin-bottom: 8px; font-family: Arial, sans-serif;"><!-- Links are populated here --></div>
  
  <script>
    function updateTimelineNav() {
      // Define all goals with their display names
      const goals = [
        { goal: "air", name: "Emissions" },
        { goal: "health", name: "Health" },
        { goal: "jobs", name: "Jobs", extra: "&scope=state" },
        { goal: "economy", name: "Economy" },
        { goal: "biodiverse", name: "Biodiversity" },
        { goal: "water", name: "Water" },
        { goal: "population", name: "Population" }
      ];
  
      // Get the current goal from the hash
      const hash = window.location.hash;
      const goalMatch = hash.match(/goal=([^&]+)/);
      const currentGoal = goalMatch ? goalMatch[1] : "air"; // Default to "air"
  
      // Find the active goal object
      const activeGoal = goals.find(g => g.goal === currentGoal) || goals[0];
      //const inactiveGoals = goals.filter(g => g.goal !== currentGoal);
  
      const allGoals = goals;

      // Clear the container
      const container = document.getElementById('timeline-nav');
      container.innerHTML = '';
  
      // Add the active goal first as "Timeline"
      const activeElement = document.createElement('span');
      activeElement.innerHTML = `<b>${activeGoal.name} Timeline</b>`;
      //container.appendChild(activeElement);
  
      // Add the goals as links
      allGoals.forEach((goal, index) => {
        // Only add separator if not the first item
        if (index > 0) {
            const separator = document.createTextNode(' | ');
            container.appendChild(separator);
        }
        
        if (goal.goal === currentGoal) {
            // Make current goal bold instead of linking it
            const boldText = document.createElement('b');
            boldText.textContent = goal.name;
            boldText.style.marginLeft = '2px';
            boldText.style.marginRight = '2px';
            container.appendChild(boldText);
        } else {
            // Create link for other goals
            const link = document.createElement('a');
            link.href = `#goal=${goal.goal}${goal.extra || ''}`;
            link.textContent = goal.name;
            link.style.marginLeft = '2px';
            link.style.marginRight = '2px';
            link.style.textDecoration = 'none';
            link.className = 'timeline-link';
            container.appendChild(link);
        }
      });
    }
  
    // Run on load and hash change
    document.addEventListener('DOMContentLoaded', updateTimelineNav);
    window.addEventListener('hashchange', updateTimelineNav);
  </script>

  <div style="float:right">
    <div class="local btn btn-primary" onclick="location.href='/realitystream/#' + window.location.hash.substr(1); return false;" style="display:none;min-width:133px;font-size:15px;border:none;">
                RealityStream
            </div>
  </div>
  <div style="overflow:visible;">

      <div id="relocatedScopeMenu" style="float:left"></div>
      <div id="template-container"></div>
      <div id="templateLoaded"></div>
     
      <!-- We might not use the same state menu as the search filter.
      <div id="relocatedStateMenu"></div>
      -->
      <div class="chart-controls" style="display:flex; flex-wrap:wrap; gap:10px;">
        <select id="entityId">
            <option value="geoId/01">Alabama</option>
            <option value="geoId/02">Alaska</option>
            <option value="geoId/04">Arizona</option>
            <option value="geoId/05">Arkansas</option>
            <option value="geoId/06">California</option>
            <option value="geoId/08">Colorado</option>
            <option value="geoId/09">Connecticut</option>
            <option value="geoId/10">Delaware</option>
            <option value="geoId/11">District of Columbia</option>
            <option value="geoId/12">Florida</option>
            <option value="geoId/13" selected>Georgia</option>
            <option value="geoId/15">Hawaii</option>
            <option value="geoId/16">Idaho</option>
            <option value="geoId/17">Illinois</option>
            <option value="geoId/18">Indiana</option>
            <option value="geoId/19">Iowa</option>
            <option value="geoId/20">Kansas</option>
            <option value="geoId/21">Kentucky</option>
            <option value="geoId/22">Louisiana</option>
            <option value="geoId/23">Maine</option>
            <option value="geoId/24">Maryland</option>
            <option value="geoId/25">Massachusetts</option>
            <option value="geoId/26">Michigan</option>
            <option value="geoId/27">Minnesota</option>
            <option value="geoId/28">Mississippi</option>
            <option value="geoId/29">Missouri</option>
            <option value="geoId/30">Montana</option>
            <option value="geoId/31">Nebraska</option>
            <option value="geoId/32">Nevada</option>
            <option value="geoId/33">New Hampshire</option>
            <option value="geoId/34">New Jersey</option>
            <option value="geoId/35">New Mexico</option>
            <option value="geoId/36">New York</option>
            <option value="geoId/37">North Carolina</option>
            <option value="geoId/38">North Dakota</option>
            <option value="geoId/39">Ohio</option>
            <option value="geoId/40">Oklahoma</option>
            <option value="geoId/41">Oregon</option>
            <option value="geoId/42">Pennsylvania</option>
            <option value="geoId/44">Rhode Island</option>
            <option value="geoId/45">South Carolina</option>
            <option value="geoId/46">South Dakota</option>
            <option value="geoId/47">Tennessee</option>
            <option value="geoId/48">Texas</option>
            <option value="geoId/49">Utah</option>
            <option value="geoId/50">Vermont</option>
            <option value="geoId/51">Virginia</option>
            <option value="geoId/53">Washington</option>
            <option value="geoId/54">West Virginia</option>
            <option value="geoId/55">Wisconsin</option>
            <option value="geoId/56">Wyoming</option>
            <option value="geoId/72">Puerto Rico</option>
        </select>
     
       <!--
          Adjust to per capita (and SqMiles) using our nav filter file:
          https://github.com/ModelEarth/localsite/blob/main/info/data/map-filters/us-states.csv

          Or call the API directly for the additional info (population and sq miles)

          show=Count_Person

          Convert 2-char state to geoId/01 in earthscape.js
      -->

        <select id="chartVariable" style="max-width:380px;"></select>
      </div>
  
        <br>
        
        <div class="whichLinesHolder" style="float:left; display: flex;">
          <label> <input value="showAll" type="radio" name="whichLines" />All &nbsp;</label>
          <div class="scope-country">
              <label> <input value="showSelected" type="radio" name="whichLines"/>11 Countries &nbsp;</label>
          </div>
          <label> <input value="showTop5" type="radio" name="whichLines" checked />Top 5 &nbsp;</label>
          <label> <input value="showBottom5" type="radio" name="whichLines" />Bottom 5 &nbsp;</label>
        </div>

        <div id="perCapitaOptions" style="float:right">
            <label> <input value="totals" type="radio" name="whichPer" checked  />Totals </label>
            <label> <input value="percapita" type="radio" name="whichPer" />Per Capita </label>
            <!--
            <label> <input value="perarea" type="radio" name="whichPer" />Per Area </label>
            -->
        </div>

        <div id="div1" class="toogleDiv" chart-wrapper>
            <canvas id="timelineChart" ></canvas>
            <div id="floating-legend" aria-hidden="false" style="display:none"><div id="legend-content"></div></div>
        </div>
        <div id="div2" class="toogleDiv" chart-wrapper>
            <canvas id="lineAreaChart" ></canvas>
        </div>

        <label>
            <input type="radio" name="toogleChartType" value="div1" checked> Line Chart
        </label>
        <label>
            <input type="radio" name="toogleChartType" value="div2"> Area Chart
        </label>
        <label>
            <input type="radio" name="toogleChartType" value="both"> Both
        </label>
    </div>

</div>
</div>
<!-- /heroTransparent -->

<div class="content contentpadding large-list">
  <div id="readmeDiv"></div>
</div>
<script>
    document.addEventListener('DOMContentLoaded', () => {
        let hash = getHash(); // Defaulted to country above.
        const perCapitaOptions = document.getElementById('perCapitaOptions');
        //const perCapitaTableSection = document.getElementById('perCapitaTableSection');
        
        if (hash.goal === "health") {
            perCapitaOptions.style.display = 'none'; // Hide Per Capita options for health
            //perCapitaTableSection.style.display = 'none'; // Hide Per Capita table for health
        } else {
            perCapitaOptions.style.display = 'block'; // Show Per Capita options for other pages
            //perCapitaTableSection.style.display = 'block'; // Show Per Capita table for other pages
        }
    });
</script>
<script>
    // Add event listener to radio buttons to call toggleDivs() on change
    // Has to reside after toogleChartType html above.
    document.querySelectorAll('input[name="toogleChartType"]').forEach((radio) => {
        radio.addEventListener('change', () => { toggleDivs(); try { if (typeof buildFloatingLegendFromChart === 'function') buildFloatingLegendFromChart(); } catch (e) { console.warn('legend rebuild failed on toggle:', e); } });
    });
    // Show the first div by default on page load
    toggleDivs();
</script>
<script>
// Floating legend helper for Chart.js timelineChart
function buildFloatingLegendFromChart() {
    const canvas = document.getElementById('timelineChart');
    if (!canvas || typeof Chart === 'undefined') return false;
    // Decide which chart(s) to build the legend for based on the chart-type toggle
    const selectedToggle = document.querySelector('input[name="toogleChartType"]:checked')?.value || 'div1';
    const timelineCanvas = document.getElementById('timelineChart');
    const lineAreaCanvas = document.getElementById('lineAreaChart');
    const timelineChartObj = (timelineCanvas && (Chart.getChart(timelineCanvas) || timelineCanvas.__chart__));
    const lineAreaChartObj = (lineAreaCanvas && (Chart.getChart(lineAreaCanvas) || lineAreaCanvas.__chart__));

    if (!timelineChartObj && !lineAreaChartObj) return false;

    // Turn off built-in legend on both charts if present
    [timelineChartObj, lineAreaChartObj].forEach((c) => {
        if (!c) return;
        try {
            if (!c.options) c.options = {};
            if (!c.options.plugins) c.options.plugins = {};
            c.options.plugins.legend = { display: false };
            try { c.update(); } catch (e) { /* ignore update errors */ }
        } catch (e) { console.warn('Could not set built-in legend display:', e); }
    });

    const legend = document.getElementById('floating-legend');
    if (!legend) return true;
    const legendContent = document.getElementById('legend-content');
    if (!legendContent) return true;
    legendContent.innerHTML = '';

    // Count datasets across available charts for diagnostics
    const timelineCount = (timelineChartObj && timelineChartObj.data && timelineChartObj.data.datasets) ? timelineChartObj.data.datasets.length : 0;
    const areaCount = (lineAreaChartObj && lineAreaChartObj.data && lineAreaChartObj.data.datasets) ? lineAreaChartObj.data.datasets.length : 0;
    const datasetCount = timelineCount + areaCount;
    // Determine selected chart count based on toggle
    const selectedCount = (selectedToggle === 'div2') ? areaCount : (selectedToggle === 'both' ? datasetCount : timelineCount);
    console.log('buildFloatingLegendFromChart: toggle=', selectedToggle, 'timeline=', timelineCount, 'area=', areaCount, 'selectedCount=', selectedCount);

    // Which-lines mode (controls which series are shown): showAll, showSelected, showTop5, showBottom5
    const whichLinesMode = document.querySelector('input[name="whichLines"]:checked')?.value || 'showTop5';

    // Helper to convert various color formats into an rgba(...) string with given alpha
    function colorToRgba(color, alpha) {
        alpha = (typeof alpha === 'number') ? alpha : 0.12;
        if (!color) return `rgba(0,0,0,${alpha})`;
        color = String(color).trim();
        // rgb(...) -> rgba(...)
        if (color.indexOf('rgb(') === 0) {
            return color.replace('rgb(', 'rgba(').replace(')', `,${alpha})`);
        }
        // rgba(...) -> override alpha
        if (color.indexOf('rgba(') === 0) {
            const parts = color.match(/rgba\((\d+),\s*(\d+),\s*(\d+),\s*([0-9.]+)\)/);
            if (parts) return `rgba(${parts[1]}, ${parts[2]}, ${parts[3]}, ${alpha})`;
        }
        // hsl(...) or hsla(...) -> convert to rgba
        if (color.toLowerCase().indexOf('hsl(') === 0 || color.toLowerCase().indexOf('hsla(') === 0) {
            const parts = color.match(/hsla?\(\s*([0-9.+-]+)\s*,\s*([0-9.+-]+)%\s*,\s*([0-9.+-]+)%\s*(?:,\s*([0-9.+-]+)\s*)?\)/i);
            if (parts) {
                let h = parseFloat(parts[1]);
                let s = parseFloat(parts[2]) / 100;
                let l = parseFloat(parts[3]) / 100;
                // parse original alpha if present
                let originalA = (typeof parts[4] !== 'undefined') ? parseFloat(parts[4]) : null;
                // convert HSL to RGB
                function hslToRgb(h, s, l) {
                    h = ((h % 360) + 360) % 360 / 360; // normalize to [0,1]
                    let r, g, b;
                    if (s === 0) {
                        r = g = b = l; // achromatic
                    } else {
                        const hue2rgb = (p, q, t) => {
                            if (t < 0) t += 1;
                            if (t > 1) t -= 1;
                            if (t < 1/6) return p + (q - p) * 6 * t;
                            if (t < 1/2) return q;
                            if (t < 2/3) return p + (q - p) * (2/3 - t) * 6;
                            return p;
                        };
                        const q = l < 0.5 ? l * (1 + s) : l + s - l * s;
                        const p = 2 * l - q;
                        r = hue2rgb(p, q, h + 1/3);
                        g = hue2rgb(p, q, h);
                        b = hue2rgb(p, q, h - 1/3);
                    }
                    return [Math.round(r * 255), Math.round(g * 255), Math.round(b * 255)];
                }
                const [r, g, b] = hslToRgb(h, s, l);
                // if original had an alpha and caller didn't pass an explicit alpha, use it
                const outA = (originalA !== null && typeof alpha === 'undefined') ? originalA : alpha;
                return `rgba(${r}, ${g}, ${b}, ${outA})`;
            }
        }
        // Hex formats #rrggbb or #rgb
        if (color[0] === '#') {
            let hex = color.slice(1);
            if (hex.length === 3) {
                hex = hex.split('').map(c => c + c).join('');
            }
            if (hex.length === 6) {
                const r = parseInt(hex.slice(0,2), 16);
                const g = parseInt(hex.slice(2,4), 16);
                const b = parseInt(hex.slice(4,6), 16);
                return `rgba(${r}, ${g}, ${b}, ${alpha})`;
            }
        }
        // Fallback: return the original color (may be a named color) with alpha applied via rgba(0,0,0,alpha) overlay
        return `rgba(0,0,0,${alpha})`;
    }

    // Apply selection visuals to a legend item
    function setItemSelectionStyle(item, color, visible) {
        const bg = visible ? colorToRgba(color, 0.12) : 'transparent';
        const border = visible ? color : 'transparent';
        item.style.background = bg;
        item.style.borderLeft = `4px solid ${border}`;
        item.classList.toggle('hidden', !visible);
    }

    // Unified legend: merge dataset labels across both charts so each country appears once
    const labelMap = new Map(); // label -> { color, charts: [{chart, index}] }
    function collectFromChart(chartObj) {
        if (!chartObj || !chartObj.data || !chartObj.data.datasets) return;
        chartObj.data.datasets.forEach((ds, i) => {
            const label = ds.label || `Series ${i+1}`;
            const color = (Array.isArray(ds.borderColor) ? ds.borderColor[0] : ds.borderColor) || (Array.isArray(ds.backgroundColor) ? ds.backgroundColor[0] : ds.backgroundColor) || '#666';
            if (!labelMap.has(label)) labelMap.set(label, { color: color, charts: [] });
            labelMap.get(label).charts.push({ chart: chartObj, index: i });
        });
    }
    collectFromChart(timelineChartObj);
    collectFromChart(lineAreaChartObj);

    // Build unified legend items (authoritative in #legend-content)
    labelMap.forEach((info, label) => {
        const item = document.createElement('div');
        item.className = 'legend-item';
        item.title = label;

        const lbl = document.createElement('span');
        lbl.textContent = label;
        item.appendChild(lbl);

        // initialize selection visuals: visible if at least one chart has dataset visible
        const visible = info.charts.some(({chart, index}) => !chart.getDatasetMeta(index).hidden);
        // If not showing all series, omit items that are currently not visible
        const whichLinesModeLocal = document.querySelector('input[name="whichLines"]:checked')?.value || 'showTop5';
        if (whichLinesModeLocal !== 'showAll' && !visible) {
            return; // don't add this legend item
        }
        setItemSelectionStyle(item, info.color, visible);

        // Toggle handler: toggles the dataset in all charts where it exists
        item.addEventListener('click', (ev) => {
            info.charts.forEach(({chart, index}) => {
                const meta = chart.getDatasetMeta(index);
                meta.hidden = !meta.hidden;
                try { chart.update(); } catch (e) {}
            });
            const nowVisible = info.charts.some(({chart, index}) => !chart.getDatasetMeta(index).hidden);
            setItemSelectionStyle(item, info.color, nowVisible);
            // Also refresh overlay clones visuals to reflect the change
            document.querySelectorAll('.overlay-legend').forEach((ov) => {
                const clone = ov.querySelector(`[data-legend-label="${CSS.escape(label)}"]`);
                if (clone) setItemSelectionStyle(clone, info.color, nowVisible);
            });
        });

        // Tag for cloning into overlays
        item.setAttribute('data-legend-label', label);
        legendContent.appendChild(item);
    });

    // Populate per-chart overlay legends by cloning authoritative items
    function ensureOverlay(containerId) {
        const container = document.getElementById(containerId);
        if (!container) return null;
        let ov = container.querySelector('.overlay-legend');
        if (!ov) {
            ov = document.createElement('div');
            ov.className = 'overlay-legend';
            const inner = document.createElement('div');
            inner.className = 'overlay-legend-content';
            ov.appendChild(inner);
            // position absolute relative to chart wrapper
            container.style.position = container.style.position || 'relative';
            container.appendChild(ov);
        }
        return ov.querySelector('.overlay-legend-content');
    }

    const div1Content = ensureOverlay('div1');
    const div2Content = ensureOverlay('div2');
    // Clear previous overlay items
    if (div1Content) div1Content.innerHTML = '';
    if (div2Content) div2Content.innerHTML = '';

    // Clone authority items into each overlay but only include series present in that chart
    const authoritativeItems = Array.from(legendContent.children);
    authoritativeItems.forEach((authItem) => {
        const label = authItem.getAttribute('data-legend-label') || authItem.title || authItem.textContent.trim();
        const info = labelMap.get(label);
        if (!info) return;

        // div1: only include if timeline chart has the dataset
        const hasInTimeline = info.charts.some(({chart}) => chart === timelineChartObj);
        if (div1Content && hasInTimeline) {
            const clone = authItem.cloneNode(true);
            clone.setAttribute('data-legend-label', label);
            // ensure pointer events work for overlay clones
            clone.style.pointerEvents = 'auto';
            // sync click to authoritative click
            clone.addEventListener('click', (ev) => {
                authItem.dispatchEvent(new MouseEvent('click', { bubbles: true }));
            });
            div1Content.appendChild(clone);
        }

        // div2: only include if area chart has the dataset
        const hasInArea = info.charts.some(({chart}) => chart === lineAreaChartObj);
        if (div2Content && hasInArea) {
            const clone = authItem.cloneNode(true);
            clone.setAttribute('data-legend-label', label);
            clone.style.pointerEvents = 'auto';
            clone.addEventListener('click', (ev) => {
                authItem.dispatchEvent(new MouseEvent('click', { bubbles: true }));
            });
            div2Content.appendChild(clone);
        }
    });

    // Refresh overlay visuals to match current dataset visibility
    try {
        authoritativeItems.forEach((authItem) => {
            const label = authItem.getAttribute('data-legend-label') || authItem.title || authItem.textContent.trim();
            const info = labelMap.get(label);
            if (!info) return;
            const nowVisible = info.charts.some(({chart, index}) => !chart.getDatasetMeta(index).hidden);
            document.querySelectorAll('.overlay-legend [data-legend-label]').forEach((el) => {
                if ((el.getAttribute('data-legend-label') || '').trim() === label) {
                    setItemSelectionStyle(el, info.color, nowVisible);
                }
            });
        });
    } catch (e) { /* ignore */ }

    // Build legend depending on toggle state
    const toggle = selectedToggle || 'div1';

    // Short-circuit if legend already matches the current toggle and counts
    if (!window._lastLegendState) window._lastLegendState = {};
    const last = window._lastLegendState;
    // If toggle and selectedCount match previous and legend already has expected children, skip rebuild
    if (last.toggle === toggle && last.selectedCount === selectedCount && last.whichLines === whichLinesMode && legendContent.children.length === last.itemsCount) {
        console.log('buildFloatingLegendFromChart: no change detected, skipping rebuild');
        // Ensure visibility still correct
        const shouldShow = selectedCount > 0 && legendContent.children.length > 0;
        legend.style.display = shouldShow ? 'block' : 'none';
        legend.setAttribute('aria-hidden', shouldShow ? 'false' : 'true');
        // Refresh selection visuals on existing legend items in case dataset visibility changed
        try {
            Array.from(legendContent.children).forEach((child) => {
                const label = (child.title && child.title.trim()) || (child.textContent && child.textContent.trim());
                if (!label) return;
                const info = labelMap.get(label);
                if (info) {
                    const visible = info.charts.some(({chart, index}) => !chart.getDatasetMeta(index).hidden);
                    setItemSelectionStyle(child, info.color, visible);
                }
            });
        } catch (e) { /* ignore */ }
        return true;
    }
    // Unified legend already built above (labelMap). Record last state for future short-circuiting.
    last.toggle = toggle;
    last.selectedCount = selectedCount;
    last.whichLines = whichLinesMode;
    last.itemsCount = legendContent.children.length;

    // Default legend mode: 'fixed' (viewport corner). Previously sticky-in-chart is disabled by default.
    if (typeof window._timelineLegendMode === 'undefined') window._timelineLegendMode = 'fixed';

    // Show legend if we built any items
    const visible = datasetCount > 0 && legendContent.children.length > 0;
    // Ensure legend is appended to body (fixed viewport legend)
    try {
        if (legend.parentElement !== document.body) document.body.appendChild(legend);
    } catch (e) { /* ignore */ }

    if (visible) {
        legend.style.display = 'block';
        legend.setAttribute('aria-hidden', 'false');
                // Place the legend at a fixed viewport location so it stays put even when canvases resize/update.
                // Small screens still get the legend inside the content area for better UX.
                try {
                    // fixed viewport placement
                    if (window.innerWidth <= 700) {
                        legend.style.position = 'fixed';
                        legend.style.left = '12px';
                        legend.style.top = '12px';
                        legend.style.right = 'auto';
                    } else {
                        legend.style.position = 'fixed';
                        legend.style.top = '120px';
                        legend.style.right = '20px';
                        legend.style.left = 'auto';
                    }
                    legend.style.zIndex = 9999;
                } catch (e) { console.warn('Could not set legend position:', e); }
    } else {
        legend.style.display = 'none';
        legend.setAttribute('aria-hidden', 'true');
    }
    console.log('buildFloatingLegendFromChart: legend visible=', !!visible, 'datasetCount=', datasetCount, 'items=', legendContent.children.length);
    return true;
}

// Try to build legend on page load for charts created later
document.addEventListener('DOMContentLoaded', () => {
    let attempts = 0;
    const maxAttempts = 12;
    const intId = setInterval(() => {
        attempts += 1;
        const ok = buildFloatingLegendFromChart();
        if (ok || attempts >= maxAttempts) clearInterval(intId);
    }, 500);
    window.addEventListener('focus', () => buildFloatingLegendFromChart());
    window.addEventListener('resize', () => setTimeout(buildFloatingLegendFromChart, 300));
    // Install visibility observer so legend only appears when chart area is visible in viewport
    try {
        if (!window._timelineLegendVisibilityObserver) {
            const legend = document.getElementById('floating-legend');
            const chartContainers = [];
            const d1 = document.getElementById('div1');
            const d2 = document.getElementById('div2');
            if (d1) chartContainers.push(d1);
            if (d2) chartContainers.push(d2);
            // If no containers found, fallback to observing the whole page (show legend normally)
            if (chartContainers.length > 0 && legend) {
                const onIntersect = (entries) => {
                    // Show legend if any container is at least partially visible
                    const anyVisible = entries.some(e => e.isIntersecting && e.intersectionRatio > 0.05);
                    // Only show legend if it has content (built) and chart datasets exist
                    const hasItems = document.getElementById('legend-content')?.children?.length > 0;
                    if (anyVisible && hasItems) {
                        legend.style.display = 'block';
                    } else {
                        legend.style.display = 'none';
                    }
                };
                const obs = new IntersectionObserver(onIntersect, { root: null, threshold: [0, 0.05, 0.2] });
                chartContainers.forEach(c => obs.observe(c));
                window._timelineLegendVisibilityObserver = obs;
            }
        }
    } catch (e) { console.warn('Legend visibility observer failed to install:', e); }
});

// Helper: position legend next to a target canvas. Also manages observers/listeners
function _positionLegendHelper(legend, targetCanvas, selectedToggle) {
    if (!legend || !targetCanvas) return;

    // Debounced reposition function
    const reposition = () => {
        try {
            const rect = targetCanvas.getBoundingClientRect();
            const lw = legend.offsetWidth || 220;
            const topPos = rect.top + window.scrollY + 20;
            if (window.innerWidth <= 700) {
                legend.style.left = Math.max(8, rect.left + 12 + window.scrollX) + 'px';
                legend.style.top = Math.max(8, rect.top + 12 + window.scrollY) + 'px';
            } else {
                const leftPos = rect.left + window.scrollX - lw - 18;
                let chosenLeft = (leftPos < 8 ? rect.right + 18 + window.scrollX : leftPos);
                // Avoid overlapping the whichLinesHolder controls
                try {
                    const which = document.querySelector('.whichLinesHolder');
                    if (which) {
                        const wRect = which.getBoundingClientRect();
                        const legendRectCandidate = { left: chosenLeft, top: Math.max(12, topPos), right: chosenLeft + lw, bottom: Math.max(12, topPos) + (legend.offsetHeight || 220) };
                        const whichRectAbs = { left: wRect.left + window.scrollX, top: wRect.top + window.scrollY, right: wRect.right + window.scrollX, bottom: wRect.bottom + window.scrollY };
                        const intersects = !(legendRectCandidate.right < whichRectAbs.left || legendRectCandidate.left > whichRectAbs.right || legendRectCandidate.bottom < whichRectAbs.top || legendRectCandidate.top > whichRectAbs.bottom);
                        if (intersects) {
                            // move legend to the right of the canvas instead
                            chosenLeft = rect.right + 18 + window.scrollX;
                        }
                    }
                } catch (e) { /* ignore */ }
                legend.style.left = chosenLeft + 'px';
                legend.style.top = Math.max(12, topPos) + 'px';
            }
            legend.style.position = 'absolute';
            legend.style.right = 'auto';
            legend.style.zIndex = 9999;
        } catch (e) { /* ignore */ }
    };

    // Clean up any previous observers/listeners we created
    try {
        if (window._timelineLegendCleanup) {
            window._timelineLegendCleanup();
        }
    } catch (e) { /* ignore */ }

    // Create a ResizeObserver on the canvas to reposition when it changes
    let ro = null;
    try {
        ro = new ResizeObserver(() => {
            reposition();
        });
        ro.observe(targetCanvas);
    } catch (e) { ro = null; }

    // Debounce helper for scroll/resize
    let timer = null;
    const onScrollOrResize = () => { clearTimeout(timer); timer = setTimeout(reposition, 80); };
    window.addEventListener('scroll', onScrollOrResize, { passive: true });
    window.addEventListener('resize', onScrollOrResize);

    // Store cleanup so next call removes these
    window._timelineLegendCleanup = () => {
        try { if (ro) ro.disconnect(); } catch (e) {}
        try { window.removeEventListener('scroll', onScrollOrResize); } catch (e) {}
        try { window.removeEventListener('resize', onScrollOrResize); } catch (e) {}
        try { clearTimeout(timer); } catch (e) {}
        window._timelineLegendCleanup = null;
    };

    // Initial position
    reposition();
}
</script>
</body>
</html>
