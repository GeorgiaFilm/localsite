<!DOCTYPE html>
<html lang="en-us">
<head>
<meta charset="utf-8">
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
<title>Data Commons - Timelines</title>
<link rel="shortcut icon" href="data:image/x-icon;," type="image/x-icon">
<meta name="viewport" content="width=device-width, initial-scale=1">

<link type="text/css" href="../css/base.css" rel="stylesheet" id="/localsite/css/base.css" />
<script type="text/javascript" src="../js/localsite.js?showheader=true&showsearch=true&scope=country"></script>

<script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
<script src="../js/earthscape.js" id="/localsite/js/earthscape.js" type="text/javascript"></script>

<script>
loadMarkdown("README.md", "readmeDiv", "_parent");

/* Also update home/index.html */
document.addEventListener('hashChangeEvent', function (elem) {
    console.log("Timeline page detects URL hashChangeEvent");
    let hash = getHash();
    if (!hash.scope) {
        hash.scope = "country"; // CUSTOM - also set in call to localsite.js above.
    }
    if (hash.scope != priorHash.scope || hash.goal != priorHash.goal) {
        const selectScope = document.getElementById("selectScope");
        if (selectScope) {
          selectScope.value = hash.scope;
        }
        updateDcidSelectFromSheet(hash.scope); // In localsite/js/earthscape.js
    }
}, false);
document.addEventListener('DOMContentLoaded', () => {
    let hash = getHash();
    if (!hash.scope) {
        hash.scope = document.getElementById('selectScope').options[document.getElementById('selectScope').selectedIndex].text;
    }
    //alert(hash.scope)
    updateDcidSelectFromSheet(hash.scope);
    
    document.addEventListener('change', function(event) {
        if (event.target.name === 'whichLines') {
          console.log('whichLines changed to ' + event.target.value);
          refreshTimeline();
        }
    });

    document.getElementById('chartVariable').addEventListener('change', (event) => {
        refreshTimeline();
    });

    // State menu change
    document.getElementById('entityId').addEventListener('change', (event) => {
        //entityId = event.target.value;
        refreshTimeline();
     });
    document.querySelectorAll('input[name="whichPer"]').forEach((radio) => {
        radio.addEventListener('change', () => {
            refreshTimeline(); // This will re-fetch emissions and population and update the chart
        });
    });
});
</script>

<style>
#selectScope {
    display: block !important;
}
.heroTransparent {
  position: relative;
  background: linear-gradient(rgba(255, 255, 255, 0.95), rgba(255, 255, 255, 0.95)), 
              url(https://model.earth/apps/img/hero/state/GA/GA-hero.jpg);
  background-size: cover; /* Scales the image to cover the div */
  background-position: center; /* Centers the image in the div */
  background-repeat: no-repeat; /* Prevents the image from repeating */
  height: auto; /* Allow height to be determined by content */
  min-height: 120px; /* Minimum height to show the background image */
}
.contenttoogleChartType {
    display: none;
}
.active {
    display: block;
}
/* Floating legend for timeline chart (fixed viewport position so it doesn't jump around)
    The legend will be fixed in the viewport (top-right by default) regardless of canvas updates.
    Individual legend items remain interactive while the container lets other clicks pass through. */
#div1 { position: relative; }
#floating-legend {
     position: fixed;
     top: 120px;
     right: 20px;
     left: auto;
     background: rgba(255,255,255,0.95);
     border-radius: 8px;
     padding: 8px;
     box-shadow: 0 6px 18px rgba(0,0,0,0.12);
     backdrop-filter: blur(6px);
     border: 1px solid rgba(0,0,0,0.04);
     z-index: 9999;
     min-width: 160px;
     max-height: 320px;
     overflow-y: auto;
     font-size: 13px;
     /* Allow clicks to pass through the legend container so underlying controls (radios, etc.) remain clickable.
         Individual legend items are interactive (see .legend-item pointer-events:auto). */
     pointer-events: none;
}

/* Overlay legend placed inside each chart wrapper (absolute within chart area) */
.overlay-legend {
    position: absolute;
    top: 8px;
    right: 8px;
    background: rgba(255,255,255,0.9);
    border-radius: 6px;
    padding: 6px;
    box-shadow: 0 6px 18px rgba(0,0,0,0.08);
    border: 1px solid rgba(0,0,0,0.04);
    z-index: 10010;
    min-width: 300px;
    max-height: 220px;
    overflow-y: auto;
    font-size: 12px;
    pointer-events: none; /* allow underlying chart interactions except for items */
    display: none; /* hidden by default; shown only via updateOverlayLegendVisibility() */
}
.overlay-legend .overlay-legend-content { pointer-events: auto; }
.overlay-legend .overlay-legend-title { pointer-events: auto; user-select: none; }

/* Overlay title (bold) */
.overlay-legend .overlay-legend-title {
    font-weight: 700;
    padding: 6px 8px;
    border-bottom: 1px solid rgba(0,0,0,0.05);
    margin-bottom: 6px;
    font-size: 13px;
}

/* On small screens place legend inside the chart area to avoid overflow */
@media (max-width: 700px) {
    #floating-legend {
        right: auto;
        left: 12px;
        top: 12px;
    }
}
.legend-item { display:flex; align-items:center; gap:8px; padding:6px 8px; margin:4px 0; border-radius:6px; cursor:pointer; transition:all 0.18s ease; 
    /* Make individual items accept pointer events while the container lets other clicks through */
    pointer-events: auto;
}
.legend-item .item-actions { display: none; }
.legend-swatch { width:14px; height:14px; border-radius:3px; box-shadow:0 0 0 1px rgba(0,0,0,0.06) inset; }
.legend-item.hidden { opacity:0.45; }
</style>

<style>
/* Keep the whichLinesHolder controls above the floating legend so radios remain clickable */
/* Ensure per-capita option radios are above the legend (prevents legend items from intercepting clicks) */
#perCapitaOptions { position: relative; z-index: 10002; }
.whichLinesHolder { position: relative; z-index: 10001; }
</style>

<style>
.legend-item:hover { transform: translateY(-1px); box-shadow: 0 8px 20px rgba(0,0,0,0.06); }

</style>


<!-- To remove -->
<style>
/*Table css start */
#table-container {
    padding: 24px 0;
}
#table-container table {
    width: 100%;
    height: auto;
    background-color: transparent;
    border: none;
    font-size: 14px;
    overflow: hidden;
    position: relative;
    text-align: left;
    line-height: 1.55em;
}
#table-container table tr:first-child {
    background-color: #e6e6e6;
    border-bottom: 1px solid #999;
    box-sizing: border-box;
    color: #555;
    font-weight: 700;
    outline: none;
    overflow: hidden;
    position: relative;
    white-space: nowrap;
    width: 100%;
    max-height: 32px;
} 
#table-container table tr:first-child th {
    min-width: 40px;
    width: auto;
    height: 32px;
    background-color: #eee;
    border-right: 1px solid #fff;
    background: #e6e6e6;
    box-sizing: border-box;
    display: inline-flex;
    flex-direction: column;
    justify-content: flex-start;
    overflow: hidden;
    position: relative;
    text-align: left;
    vertical-align: bottom;
}
#table-container table tr:not(:first-child) {
    background-color: #fff;
    color: #333;
    display: inline-block;
    overflow: visible;
    position: relative;
    white-space: nowrap;
}
#table-container table tr:not(:first-child) td {
    border-right: 1px solid #fff;
    border-bottom: 1px solid #ccc;
    box-sizing: border-box;
    display: inline-block;
    outline: none;
    overflow: hidden;
    padding: 4px;
    position: relative;
    text-overflow: ellipsis;
    vertical-align: middle;
    white-space: nowrap;
    font-size: 13px;
    height: 30px;  /*!important;*/
    padding-top: 6px; /*!important;*/
}
#table-container table tr:first-child th.Topic,
#table-container table tr:not(:first-child) td.num0 {
    width: 80px;
}
#table-container table tr:first-child th.Subtopic,
#table-container table tr:not(:first-child) td.num1 {
    width: 80px;
}
#table-container table tr:first-child th.DCID,
#table-container table tr:not(:first-child) td.num2 {
    width: 232px;
}    
#table-container table tr:first-child th.Title,
#table-container table tr:not(:first-child) td.num3 {
    width: 168px;
}
#table-container table tr:first-child th.IsUsable,
#table-container table tr:not(:first-child) td.num4 {
    width: 80px;
}
#table-container table tr:first-child th.Scope,
#table-container table tr:not(:first-child) td.num5 {
    width: 128px;
}
#table-container table tr:first-child th.StartYear,
#table-container table tr:not(:first-child) td.num6 {
    width: 96px;
}
#table-container table tr:first-child th.EndYear,
#table-container table tr:not(:first-child) td.num7 {
    width: 96px;
}
#table-container table tr:first-child th.Source,
#table-container table tr:not(:first-child) td.num8 {
    width: 232px;
}
#table-container table tr:first-child th.Notes,
#table-container table tr:not(:first-child) td.num9 {
    width: 64px;
}
/* Table css end */ 
</style>

</head>

<body>


<div class="heroTransparent notdark">

<div class="content contentpadding large-list">
  <!-- Also update in home repo -->
  <div id="timeline-nav" style="margin-bottom: 8px; font-family: Arial, sans-serif;"><!-- Links are populated here --></div>
  
  <script>
    function updateTimelineNav() {
      // Define all goals with their display names
      const goals = [
        { goal: "air", name: "Emissions" },
        { goal: "health", name: "Health" },
        { goal: "jobs", name: "Jobs", extra: "&scope=state" },
        { goal: "economy", name: "Economy" },
        { goal: "biodiverse", name: "Biodiversity" },
        { goal: "water", name: "Water" },
        { goal: "population", name: "Population" }
      ];
  
      // Get the current goal from the hash
      const hash = window.location.hash;
      const goalMatch = hash.match(/goal=([^&]+)/);
      const currentGoal = goalMatch ? goalMatch[1] : "air"; // Default to "air"
  
      // Find the active goal object
      const activeGoal = goals.find(g => g.goal === currentGoal) || goals[0];
      //const inactiveGoals = goals.filter(g => g.goal !== currentGoal);
  
      const allGoals = goals;

      // Clear the container
      const container = document.getElementById('timeline-nav');
      container.innerHTML = '';
  
      // Add the active goal first as "Timeline"
      const activeElement = document.createElement('span');
      activeElement.innerHTML = `<b>${activeGoal.name} Timeline</b>`;
      //container.appendChild(activeElement);
  
      // Add the goals as links
      allGoals.forEach((goal, index) => {
        // Only add separator if not the first item
        if (index > 0) {
            const separator = document.createTextNode(' | ');
            container.appendChild(separator);
        }
        
        if (goal.goal === currentGoal) {
            // Make current goal bold instead of linking it
            const boldText = document.createElement('b');
            boldText.textContent = goal.name;
            boldText.style.marginLeft = '2px';
            boldText.style.marginRight = '2px';
            container.appendChild(boldText);
        } else {
            // Create link for other goals
            const link = document.createElement('a');
            link.href = `#goal=${goal.goal}${goal.extra || ''}`;
            link.textContent = goal.name;
            link.style.marginLeft = '2px';
            link.style.marginRight = '2px';
            link.style.textDecoration = 'none';
            link.className = 'timeline-link';
            container.appendChild(link);
        }
      });
    }
  
    // Run on load and hash change
    document.addEventListener('DOMContentLoaded', updateTimelineNav);
    window.addEventListener('hashchange', updateTimelineNav);
  </script>

  <div style="float:right">
    <div class="local btn btn-primary" onclick="location.href='/realitystream/#' + window.location.hash.substr(1); return false;" style="display:none;min-width:133px;font-size:15px;border:none;">
                RealityStream
            </div>
  </div>
  <div style="overflow:visible;">

      <div id="relocatedScopeMenu" style="float:left"></div>
      <div id="template-container"></div>
      <div id="templateLoaded"></div>
     
      <!-- We might not use the same state menu as the search filter.
      <div id="relocatedStateMenu"></div>
      -->
      <div class="chart-controls" style="display:flex; flex-wrap:wrap; gap:10px;">
        <select id="entityId">
            <option value="geoId/01">Alabama</option>
            <option value="geoId/02">Alaska</option>
            <option value="geoId/04">Arizona</option>
            <option value="geoId/05">Arkansas</option>
            <option value="geoId/06">California</option>
            <option value="geoId/08">Colorado</option>
            <option value="geoId/09">Connecticut</option>
            <option value="geoId/10">Delaware</option>
            <option value="geoId/11">District of Columbia</option>
            <option value="geoId/12">Florida</option>
            <option value="geoId/13" selected>Georgia</option>
            <option value="geoId/15">Hawaii</option>
            <option value="geoId/16">Idaho</option>
            <option value="geoId/17">Illinois</option>
            <option value="geoId/18">Indiana</option>
            <option value="geoId/19">Iowa</option>
            <option value="geoId/20">Kansas</option>
            <option value="geoId/21">Kentucky</option>
            <option value="geoId/22">Louisiana</option>
            <option value="geoId/23">Maine</option>
            <option value="geoId/24">Maryland</option>
            <option value="geoId/25">Massachusetts</option>
            <option value="geoId/26">Michigan</option>
            <option value="geoId/27">Minnesota</option>
            <option value="geoId/28">Mississippi</option>
            <option value="geoId/29">Missouri</option>
            <option value="geoId/30">Montana</option>
            <option value="geoId/31">Nebraska</option>
            <option value="geoId/32">Nevada</option>
            <option value="geoId/33">New Hampshire</option>
            <option value="geoId/34">New Jersey</option>
            <option value="geoId/35">New Mexico</option>
            <option value="geoId/36">New York</option>
            <option value="geoId/37">North Carolina</option>
            <option value="geoId/38">North Dakota</option>
            <option value="geoId/39">Ohio</option>
            <option value="geoId/40">Oklahoma</option>
            <option value="geoId/41">Oregon</option>
            <option value="geoId/42">Pennsylvania</option>
            <option value="geoId/44">Rhode Island</option>
            <option value="geoId/45">South Carolina</option>
            <option value="geoId/46">South Dakota</option>
            <option value="geoId/47">Tennessee</option>
            <option value="geoId/48">Texas</option>
            <option value="geoId/49">Utah</option>
            <option value="geoId/50">Vermont</option>
            <option value="geoId/51">Virginia</option>
            <option value="geoId/53">Washington</option>
            <option value="geoId/54">West Virginia</option>
            <option value="geoId/55">Wisconsin</option>
            <option value="geoId/56">Wyoming</option>
            <option value="geoId/72">Puerto Rico</option>
        </select>
     
       <!--
          Adjust to per capita (and SqMiles) using our nav filter file:
          https://github.com/ModelEarth/localsite/blob/main/info/data/map-filters/us-states.csv

          Or call the API directly for the additional info (population and sq miles)

          show=Count_Person

          Convert 2-char state to geoId/01 in earthscape.js
      -->

        <select id="chartVariable" style="max-width:380px;"></select>
      </div>
  
        <br>
        
        <div class="whichLinesHolder" style="float:left; display: flex;">
          <label> <input value="showAll" type="radio" name="whichLines" />All &nbsp;</label>
          <div class="scope-country">
              <label> <input value="showSelected" type="radio" name="whichLines"/>11 Countries &nbsp;</label>
          </div>
          <label> <input value="showTop5" type="radio" name="whichLines" checked />Top 5 &nbsp;</label>
          <label> <input value="showBottom5" type="radio" name="whichLines" />Bottom 5 &nbsp;</label>
        </div>

        <div id="perCapitaOptions" style="float:right">
            <label> <input value="totals" type="radio" name="whichPer" checked  />Totals </label>
            <label> <input value="percapita" type="radio" name="whichPer" />Per Capita </label>
            <!--
            <label> <input value="perarea" type="radio" name="whichPer" />Per Area </label>
            -->
        </div>

        <div id="div1" class="toogleDiv" chart-wrapper>
            <canvas id="timelineChart" ></canvas>
            <div id="floating-legend" aria-hidden="false" style="display:none"><div id="legend-content"></div></div>
        </div>
        <div id="div2" class="toogleDiv" chart-wrapper>
            <canvas id="lineAreaChart" ></canvas>
        </div>

        <label>
            <input type="radio" name="toogleChartType" value="div1" checked> Line Chart
        </label>
        <label>
            <input type="radio" name="toogleChartType" value="div2"> Area Chart
        </label>
        <label>
            <input type="radio" name="toogleChartType" value="both"> Both
        </label>
    </div>

</div>
</div>
<!-- /heroTransparent -->

<div class="content contentpadding large-list">
  <div id="readmeDiv"></div>
</div>
<script>
    document.addEventListener('DOMContentLoaded', () => {
        let hash = getHash(); // Defaulted to country above.
        const perCapitaOptions = document.getElementById('perCapitaOptions');
        //const perCapitaTableSection = document.getElementById('perCapitaTableSection');
        
        if (hash.goal === "health") {
            perCapitaOptions.style.display = 'none'; // Hide Per Capita options for health
            //perCapitaTableSection.style.display = 'none'; // Hide Per Capita table for health
        } else {
            perCapitaOptions.style.display = 'block'; // Show Per Capita options for other pages
            //perCapitaTableSection.style.display = 'block'; // Show Per Capita table for other pages
        }
    });
</script>
<script>
    // Add event listener to radio buttons to call toggleDivs() on change
    // Has to reside after toogleChartType html above.
    document.querySelectorAll('input[name="toogleChartType"]').forEach((radio) => {
        radio.addEventListener('change', () => { toggleDivs(); try { if (typeof buildFloatingLegendFromChart === 'function') buildFloatingLegendFromChart(); } catch (e) { console.warn('legend rebuild failed on toggle:', e); } });
    });
    // Show the first div by default on page load
    toggleDivs();
</script>
<script>
// Floating legend helper for Chart.js timelineChart
function buildFloatingLegendFromChart() {
    const canvas = document.getElementById('timelineChart');
    // Tidy up any duplicate overlays before building
    try { tidyOverlayLegends(); } catch (e) { /* ignore */ }
    if (!canvas || typeof Chart === 'undefined') return false;
    // Decide which chart(s) to build the legend for based on the chart-type toggle
    const selectedToggle = document.querySelector('input[name="toogleChartType"]:checked')?.value || 'div1';
    const timelineCanvas = document.getElementById('timelineChart');
    const lineAreaCanvas = document.getElementById('lineAreaChart');
    const timelineChartObj = (timelineCanvas && (Chart.getChart(timelineCanvas) || timelineCanvas.__chart__));
    const lineAreaChartObj = (lineAreaCanvas && (Chart.getChart(lineAreaCanvas) || lineAreaCanvas.__chart__));

    if (!timelineChartObj && !lineAreaChartObj) return false;

    // Turn off built-in legend on both charts if present
    [timelineChartObj, lineAreaChartObj].forEach((c) => {
        if (!c) return;
        try {
            if (!c.options) c.options = {};
            if (!c.options.plugins) c.options.plugins = {};
            c.options.plugins.legend = { display: false };
            try { c.update(); } catch (e) { /* ignore update errors */ }
        } catch (e) { console.warn('Could not set built-in legend display:', e); }
    });

    const legend = document.getElementById('floating-legend');
    if (!legend) return true;
    const legendContent = document.getElementById('legend-content');
    if (!legendContent) return true;
    legendContent.innerHTML = '';

    // Count datasets across available charts for diagnostics
    const timelineCount = (timelineChartObj && timelineChartObj.data && timelineChartObj.data.datasets) ? timelineChartObj.data.datasets.length : 0;
    const areaCount = (lineAreaChartObj && lineAreaChartObj.data && lineAreaChartObj.data.datasets) ? lineAreaChartObj.data.datasets.length : 0;
    const datasetCount = timelineCount + areaCount;
    // Determine selected chart count based on toggle
    const selectedCount = (selectedToggle === 'div2') ? areaCount : (selectedToggle === 'both' ? datasetCount : timelineCount);
    console.log('buildFloatingLegendFromChart: toggle=', selectedToggle, 'timeline=', timelineCount, 'area=', areaCount, 'selectedCount=', selectedCount);

    // Which-lines mode (controls which series are shown): showAll, showSelected, showTop5, showBottom5
    const whichLinesMode = document.querySelector('input[name="whichLines"]:checked')?.value || 'showTop5';

    // Helper to convert various color formats into an rgba(...) string with given alpha
    function colorToRgba(color, alpha) {
        alpha = (typeof alpha === 'number') ? alpha : 0.12;
        if (!color) return `rgba(0,0,0,${alpha})`;
        color = String(color).trim();
        // rgb(...) -> rgba(...)
        if (color.indexOf('rgb(') === 0) {
            return color.replace('rgb(', 'rgba(').replace(')', `,${alpha})`);
        }
        // rgba(...) -> override alpha
        if (color.indexOf('rgba(') === 0) {
            const parts = color.match(/rgba\((\d+),\s*(\d+),\s*(\d+),\s*([0-9.]+)\)/);
            if (parts) return `rgba(${parts[1]}, ${parts[2]}, ${parts[3]}, ${alpha})`;
        }
        // hsl(...) or hsla(...) -> convert to rgba
        if (color.toLowerCase().indexOf('hsl(') === 0 || color.toLowerCase().indexOf('hsla(') === 0) {
            const parts = color.match(/hsla?\(\s*([0-9.+-]+)\s*,\s*([0-9.+-]+)%\s*,\s*([0-9.+-]+)%\s*(?:,\s*([0-9.+-]+)\s*)?\)/i);
            if (parts) {
                let h = parseFloat(parts[1]);
                let s = parseFloat(parts[2]) / 100;
                let l = parseFloat(parts[3]) / 100;
                // parse original alpha if present
                let originalA = (typeof parts[4] !== 'undefined') ? parseFloat(parts[4]) : null;
                // convert HSL to RGB
                function hslToRgb(h, s, l) {
                    h = ((h % 360) + 360) % 360 / 360; // normalize to [0,1]
                    let r, g, b;
                    if (s === 0) {
                        r = g = b = l; // achromatic
                    } else {
                        const hue2rgb = (p, q, t) => {
                            if (t < 0) t += 1;
                            if (t > 1) t -= 1;
                            if (t < 1/6) return p + (q - p) * 6 * t;
                            if (t < 1/2) return q;
                            if (t < 2/3) return p + (q - p) * (2/3 - t) * 6;
                            return p;
                        };
                        const q = l < 0.5 ? l * (1 + s) : l + s - l * s;
                        const p = 2 * l - q;
                        r = hue2rgb(p, q, h + 1/3);
                        g = hue2rgb(p, q, h);
                        b = hue2rgb(p, q, h - 1/3);
                    }
                    return [Math.round(r * 255), Math.round(g * 255), Math.round(b * 255)];
                }
                const [r, g, b] = hslToRgb(h, s, l);
                // if original had an alpha and caller didn't pass an explicit alpha, use it
                const outA = (originalA !== null && typeof alpha === 'undefined') ? originalA : alpha;
                return `rgba(${r}, ${g}, ${b}, ${outA})`;
            }
        }
        // Hex formats #rrggbb or #rgb
        if (color[0] === '#') {
            let hex = color.slice(1);
            if (hex.length === 3) {
                hex = hex.split('').map(c => c + c).join('');
            }
            if (hex.length === 6) {
                const r = parseInt(hex.slice(0,2), 16);
                const g = parseInt(hex.slice(2,4), 16);
                const b = parseInt(hex.slice(4,6), 16);
                return `rgba(${r}, ${g}, ${b}, ${alpha})`;
            }
        }
        // Fallback: return the original color (may be a named color) with alpha applied via rgba(0,0,0,alpha) overlay
        return `rgba(0,0,0,${alpha})`;
    }

    // Apply selection visuals to a legend item
    function setItemSelectionStyle(item, color, visible) {
        const bg = visible ? colorToRgba(color, 0.12) : 'transparent';
        const border = visible ? color : 'transparent';
        item.style.background = bg;
        item.style.borderLeft = `4px solid ${border}`;
        item.classList.toggle('hidden', !visible);
    }

    // Unified legend: merge dataset labels across both charts so each country appears once
    const labelMap = new Map(); // label -> { color, charts: [{chart, index}] }
    function collectFromChart(chartObj) {
        if (!chartObj || !chartObj.data || !chartObj.data.datasets) return;
        chartObj.data.datasets.forEach((ds, i) => {
            const label = ds.label || `Series ${i+1}`;
            const color = (Array.isArray(ds.borderColor) ? ds.borderColor[0] : ds.borderColor) || (Array.isArray(ds.backgroundColor) ? ds.backgroundColor[0] : ds.backgroundColor) || '#666';
            if (!labelMap.has(label)) labelMap.set(label, { color: color, charts: [] });
            labelMap.get(label).charts.push({ chart: chartObj, index: i });
        });
    }
    collectFromChart(timelineChartObj);
    collectFromChart(lineAreaChartObj);

    // Build unified legend items (authoritative in #legend-content)
    labelMap.forEach((info, label) => {
        const item = document.createElement('div');
        item.className = 'legend-item';
        item.title = label;

        const lbl = document.createElement('span');
        lbl.textContent = label;
        item.appendChild(lbl);

        // initialize selection visuals: visible if at least one chart has dataset visible
        const visible = info.charts.some(({chart, index}) => !chart.getDatasetMeta(index).hidden);
        // If not showing all series, omit items that are currently not visible
        const whichLinesModeLocal = document.querySelector('input[name="whichLines"]:checked')?.value || 'showTop5';
        if (whichLinesModeLocal !== 'showAll' && !visible) {
            return; // don't add this legend item
        }
        setItemSelectionStyle(item, info.color, visible);

        // Toggle handler: toggles the dataset in all charts where it exists
        item.addEventListener('click', (ev) => {
            info.charts.forEach(({chart, index}) => {
                const meta = chart.getDatasetMeta(index);
                meta.hidden = !meta.hidden;
                try { chart.update(); } catch (e) {}
            });
            const nowVisible = info.charts.some(({chart, index}) => !chart.getDatasetMeta(index).hidden);
            setItemSelectionStyle(item, info.color, nowVisible);
            // Also refresh overlay clones visuals to reflect the change
            document.querySelectorAll('.overlay-legend').forEach((ov) => {
                const clone = ov.querySelector(`[data-legend-label="${CSS.escape(label)}"]`);
                if (clone) setItemSelectionStyle(clone, info.color, nowVisible);
            });
        });

        // Tag for cloning into overlays
        item.setAttribute('data-legend-label', label);
        legendContent.appendChild(item);
    });

    // Populate per-chart overlay legends by cloning authoritative items
    // Map of scope keys to human-readable overlay title
    const SCOPE_TITLES = {
        country: 'Countries',
        state: 'States',
        county: 'Counties'
    };

    function getScopeKeyFromHash() {
        try {
            const h = window.location.hash ? new URLSearchParams(window.location.hash.substring(1)) : null;
            if (h) {
                const geoview = (h.get('geoview') || '').toLowerCase();
                if (geoview === 'countries' || geoview === 'country' || geoview === 'earth') return 'country';
                if (geoview === 'states' || geoview === 'state') return 'state';
                if (geoview === 'counties' || geoview === 'county') return 'county';
                if (h.get('state')) return 'state';
                // If geo param looks like a list of county FIPS (many commas) assume county
                const geo = h.get('geo') || h.get('geoIds') || h.get('geo_id');
                if (geo && geo.indexOf(',') >= 0) {
                    // If tokens look like county FIPS (USxxxxx) or many numeric codes, treat as county
                    const tokens = geo.split(',').map(s => s.trim()).filter(Boolean);
                    const numericCount = tokens.filter(t => /^\d+$/.test(t)).length;
                    const usFipsLike = tokens.filter(t => /^US\d{2,}/i.test(t)).length;
                    if (tokens.length > 2 && (numericCount > 2 || usFipsLike > 0)) return 'county';
                }
            }
        } catch (e) { /* ignore */ }
        // Fallback: check visible controls such as #entityId
        try {
            const select = document.getElementById('entityId');
            if (select && select.value) {
                const val = String(select.value).trim();
                // Common localsite convention: geoId/NN -> state
                if (val.indexOf('geoId/') === 0 || /^geoId:\/\//i.test(val)) return 'state';
                // Two-letter uppercase values likely indicate country codes (e.g. US, GB)
                if (/^[A-Za-z]{2}$/.test(val)) return 'country';
                // If value contains 'country' keyword, treat as country
                if (val.toLowerCase().indexOf('country') >= 0) return 'country';
            }
        } catch (e) { /* ignore */ }
        return 'country';
    }

    function getOverlayTitleText() {
        const key = getScopeKeyFromHash();
        return SCOPE_TITLES[key] || '';
    }

    function ensureOverlay(containerId) {
        const container = document.getElementById(containerId);
        if (!container) return null;
        // Remove any duplicate overlays so we start from a clean state
        try { tidyOverlayLegends(); } catch (e) { /* ignore */ }
        // Prefer hero root for lookup since overlays are appended there for cross-chart dragging
        const heroRoot = document.querySelector('.heroTransparent.notdark') || document.querySelector('.heroTransparent') || container;
        // Look for existing overlays across the document that were created for this containerId
        let ov = null;
        try {
            const existing = Array.from(document.querySelectorAll(`.overlay-legend[data-overlay-for="${containerId}"]`));
            console.debug('[ensureOverlay] existing overlays for containerId=', containerId, 'count=', existing.length);
            if (existing.length > 0) {
                // Reuse first, remove any extras
                ov = existing[0];
                for (let i = 1; i < existing.length; i++) {
                    try { existing[i].remove(); } catch (e) { /* ignore */ }
                }
            } else {
                // No explicit overlay-for found; see if heroRoot has a single orphan overlay we can reclaim
                const orphans = Array.from(heroRoot.querySelectorAll('.overlay-legend:not([data-overlay-for])'));
                if (orphans.length === 1) {
                    ov = orphans[0];
                    ov.setAttribute('data-overlay-for', containerId);
                    console.debug('[ensureOverlay] reclaimed orphan overlay for', containerId);
                } else {
                    // Fall back to local container check
                    ov = container.querySelector(`.overlay-legend[data-overlay-for="${containerId}"]`) || container.querySelector('.overlay-legend');
                }
            }
            console.debug('[ensureOverlay] lookup', { containerId, heroRootChildren: heroRoot.querySelectorAll('.overlay-legend').length, found: !!ov });
        } catch (e) {
            ov = container.querySelector('.overlay-legend');
        }

        if (!ov) {
            console.debug('[ensureOverlay] creating overlay for', containerId, 'heroRootChildrenBeforeCreate=', heroRoot.querySelectorAll('.overlay-legend').length);
            ov = document.createElement('div');
            ov.className = 'overlay-legend';
            // Mark which container this overlay belongs to so future lookups find it
            ov.setAttribute('data-overlay-for', containerId);
            // title (bold)
            const title = document.createElement('div');
            title.className = 'overlay-legend-title';
            title.textContent = getOverlayTitleText();
            ov.appendChild(title);
            const inner = document.createElement('div');
            inner.className = 'overlay-legend-content';
            ov.appendChild(inner);
            // position absolute relative to chart wrapper
            // Prefer placing overlays inside the main hero area so they can be dragged across it.
            try { heroRoot.style.position = heroRoot.style.position || 'relative'; } catch (e) { /* ignore */ }
            // Append overlay to the hero root so it can be moved across the entire hero area
            try { heroRoot.appendChild(ov); } catch (e) { try { container.appendChild(ov); } catch (ee) { /* ignore */ } }
            // make draggable and restore saved position
            try { makeOverlayDraggable(ov, containerId); } catch (e) { /* ignore */ }
        }
        // Update title each time (in case scope changed)
        try {
            const title = ov.querySelector('.overlay-legend-title');
            if (title) title.textContent = getOverlayTitleText();
        } catch (e) { /* ignore */ }
        // Ensure draggable handlers are attached even for existing overlays
        try { makeOverlayDraggable(ov, containerId); } catch (e) { /* ignore */ }
        return ov.querySelector('.overlay-legend-content');
    }

    // Make an overlay draggable by its title. Positions are clamped within the container
    // and persisted to localStorage under key `overlayPos_<containerId>`.
    function makeOverlayDraggable(ov, containerId) {
        if (!ov || !containerId) return;
        // Avoid attaching multiple handlers
        if (ov._draggableAttached) return;
        ov._draggableAttached = true;

    // Prefer the element the overlay is appended to (ov.parentElement), e.g. the hero root,
    // so dragging is clamped within that root. Fall back to the original containerId element.
    const container = ov.parentElement || document.getElementById(containerId) || document.body;
    try { if (container) container.style.position = container.style.position || 'relative'; } catch (e) { /* ignore */ }

        const handle = ov.querySelector('.overlay-legend-title') || ov;
        handle.style.cursor = 'move';

        // Restore persisted position if available
        try {
            const key = 'overlayPos_' + containerId;
            const raw = localStorage.getItem(key);
            if (raw) {
                const pos = JSON.parse(raw);
                if (typeof pos.left !== 'undefined' && typeof pos.top !== 'undefined') {
                    ov.style.position = 'absolute';
                    ov.style.left = (parseFloat(pos.left) || 0) + 'px';
                    ov.style.top = (parseFloat(pos.top) || 0) + 'px';
                    ov.style.right = 'auto';
                }
            }
        } catch (e) { /* ignore */ }

        let dragging = false;
        let startX = 0, startY = 0, startLeft = 0, startTop = 0;

        const onPointerDown = (ev) => {
            // Only left button
            if (ev.button && ev.button !== 0) return;
            ev.preventDefault();
            dragging = true;
            const rect = ov.getBoundingClientRect();
            const containerRect = container.getBoundingClientRect();
            startX = ev.clientX;
            startY = ev.clientY;
            // Compute position relative to container
            startLeft = rect.left - containerRect.left + container.scrollLeft;
            startTop = rect.top - containerRect.top + container.scrollTop;
            ov.style.position = 'absolute';
            ov.style.right = 'auto';
            // capture pointer if supported
            try { if (ev.target.setPointerCapture) ev.target.setPointerCapture(ev.pointerId); } catch (e) {}
            document.addEventListener('pointermove', onPointerMove);
            document.addEventListener('pointerup', onPointerUp);
        };

        const onPointerMove = (ev) => {
            if (!dragging) return;
            ev.preventDefault();
            const dx = ev.clientX - startX;
            const dy = ev.clientY - startY;
            let newLeft = startLeft + dx;
            let newTop = startTop + dy;
            // Clamp within container bounds
            try {
                const ovRect = ov.getBoundingClientRect();
                const containerRect = container.getBoundingClientRect();
                const maxLeft = Math.max(0, containerRect.width - ovRect.width);
                const maxTop = Math.max(0, containerRect.height - ovRect.height);
                newLeft = Math.max(0, Math.min(newLeft, maxLeft));
                newTop = Math.max(0, Math.min(newTop, maxTop));
            } catch (e) { /* ignore clamping errors */ }
            ov.style.left = newLeft + 'px';
            ov.style.top = newTop + 'px';
        };

        const onPointerUp = (ev) => {
            if (!dragging) return;
            dragging = false;
            try { if (ev.target.releasePointerCapture) ev.target.releasePointerCapture(ev.pointerId); } catch (e) {}
            document.removeEventListener('pointermove', onPointerMove);
            document.removeEventListener('pointerup', onPointerUp);
            // Persist position
            try {
                const key = 'overlayPos_' + containerId;
                const left = parseFloat(ov.style.left || '0') || 0;
                const top = parseFloat(ov.style.top || '0') || 0;
                localStorage.setItem(key, JSON.stringify({ left: left, top: top }));
            } catch (e) { /* ignore persistence errors */ }
        };

        handle.addEventListener('pointerdown', onPointerDown, { passive: false });

        // Also allow double-click to reset position
        handle.addEventListener('dblclick', () => {
            try {
                ov.style.left = '';
                ov.style.top = '';
                ov.style.right = '';
                const key = 'overlayPos_' + containerId;
                localStorage.removeItem(key);
            } catch (e) { /* ignore */ }
        });
    }

    const div1Content = ensureOverlay('div1');
    const div2Content = ensureOverlay('div2');
    // Clear previous overlay items
    if (div1Content) div1Content.innerHTML = '';
    if (div2Content) div2Content.innerHTML = '';

    // Clone authority items into each overlay but only include series present in that chart
    const authoritativeItems = Array.from(legendContent.children);
    authoritativeItems.forEach((authItem) => {
        const label = authItem.getAttribute('data-legend-label') || authItem.title || authItem.textContent.trim();
        const info = labelMap.get(label);
        if (!info) return;

        // div1: only include if timeline chart has the dataset
        const hasInTimeline = info.charts.some(({chart}) => chart === timelineChartObj);
        if (div1Content && hasInTimeline) {
            const clone = authItem.cloneNode(true);
            clone.setAttribute('data-legend-label', label);
            // ensure pointer events work for overlay clones
            clone.style.pointerEvents = 'auto';
            // sync click to authoritative click
            clone.addEventListener('click', (ev) => {
                authItem.dispatchEvent(new MouseEvent('click', { bubbles: true }));
            });
            div1Content.appendChild(clone);
        }

        // div2: only include if area chart has the dataset
        const hasInArea = info.charts.some(({chart}) => chart === lineAreaChartObj);
        if (div2Content && hasInArea) {
            const clone = authItem.cloneNode(true);
            clone.setAttribute('data-legend-label', label);
            clone.style.pointerEvents = 'auto';
            clone.addEventListener('click', (ev) => {
                authItem.dispatchEvent(new MouseEvent('click', { bubbles: true }));
            });
            div2Content.appendChild(clone);
        }
    });

    // Refresh overlay visuals to match current dataset visibility
    try {
        authoritativeItems.forEach((authItem) => {
            const label = authItem.getAttribute('data-legend-label') || authItem.title || authItem.textContent.trim();
            const info = labelMap.get(label);
            if (!info) return;
            const nowVisible = info.charts.some(({chart, index}) => !chart.getDatasetMeta(index).hidden);
            document.querySelectorAll('.overlay-legend [data-legend-label]').forEach((el) => {
                if ((el.getAttribute('data-legend-label') || '').trim() === label) {
                    setItemSelectionStyle(el, info.color, nowVisible);
                }
            });
        });
    } catch (e) { /* ignore */ }

    // Build legend depending on toggle state
    const toggle = selectedToggle || 'div1';

    // Short-circuit if legend already matches the current toggle and counts
    if (!window._lastLegendState) window._lastLegendState = {};
    const last = window._lastLegendState;
    // If toggle and selectedCount match previous and legend already has expected children, skip rebuild
    if (last.toggle === toggle && last.selectedCount === selectedCount && last.whichLines === whichLinesMode && legendContent.children.length === last.itemsCount) {
        console.log('buildFloatingLegendFromChart: no change detected, skipping rebuild');
        // Ensure visibility still correct
        const shouldShow = selectedCount > 0 && legendContent.children.length > 0;
        legend.style.display = shouldShow ? 'block' : 'none';
        legend.setAttribute('aria-hidden', shouldShow ? 'false' : 'true');
        // Refresh selection visuals on existing legend items in case dataset visibility changed
        try {
            Array.from(legendContent.children).forEach((child) => {
                const label = (child.title && child.title.trim()) || (child.textContent && child.textContent.trim());
                if (!label) return;
                const info = labelMap.get(label);
                if (info) {
                    const visible = info.charts.some(({chart, index}) => !chart.getDatasetMeta(index).hidden);
                    setItemSelectionStyle(child, info.color, visible);
                }
            });
        } catch (e) { /* ignore */ }
        return true;
    }
    // Unified legend already built above (labelMap). Record last state for future short-circuiting.
    last.toggle = toggle;
    last.selectedCount = selectedCount;
    last.whichLines = whichLinesMode;
    last.itemsCount = legendContent.children.length;

    // Default legend mode: 'fixed' (viewport corner). Previously sticky-in-chart is disabled by default.
    if (typeof window._timelineLegendMode === 'undefined') window._timelineLegendMode = 'fixed';

    // Show legend if we built any items
    const visible = datasetCount > 0 && legendContent.children.length > 0;
    // Ensure legend is appended to body (fixed viewport legend)
    try {
        if (legend.parentElement !== document.body) document.body.appendChild(legend);
    } catch (e) { /* ignore */ }

    if (visible) {
        legend.style.display = 'block';
        legend.setAttribute('aria-hidden', 'false');
                // Place the legend at a fixed viewport location so it stays put even when canvases resize/update.
                // Small screens still get the legend inside the content area for better UX.
                try {
                    // fixed viewport placement
                    if (window.innerWidth <= 700) {
                        legend.style.position = 'fixed';
                        legend.style.left = '12px';
                        legend.style.top = '12px';
                        legend.style.right = 'auto';
                    } else {
                        legend.style.position = 'fixed';
                        legend.style.top = '120px';
                        legend.style.right = '20px';
                        legend.style.left = 'auto';
                    }
                    legend.style.zIndex = 9999;
                } catch (e) { console.warn('Could not set legend position:', e); }
    } else {
        legend.style.display = 'none';
        legend.setAttribute('aria-hidden', 'true');
    }
    console.log('buildFloatingLegendFromChart: legend visible=', !!visible, 'datasetCount=', datasetCount, 'items=', legendContent.children.length);
    // After building the legend and overlay clones, let the page decide visibility
    try {
        if (window.updateOverlayLegendVisibility) window.updateOverlayLegendVisibility();
    } catch (e) { /* ignore */ }
    // Ensure titles are up-to-date after rebuild
    try { if (typeof updateOverlayTitles === 'function') updateOverlayTitles(); } catch (e) { /* ignore */ }
    return true;
}

// Try to build legend on page load for charts created later
document.addEventListener('DOMContentLoaded', () => {
    let attempts = 0;
    const maxAttempts = 12;
    const intId = setInterval(() => {
        attempts += 1;
        const ok = buildFloatingLegendFromChart();
        if (ok || attempts >= maxAttempts) clearInterval(intId);
    }, 500);
    window.addEventListener('focus', () => buildFloatingLegendFromChart());
    window.addEventListener('resize', () => setTimeout(buildFloatingLegendFromChart, 300));
    // Install visibility observer so legend only appears when chart area is visible in viewport
    try {
        if (!window._timelineLegendVisibilityObserver) {
            const legend = document.getElementById('floating-legend');
            const chartContainers = [];
            const d1 = document.getElementById('div1');
            const d2 = document.getElementById('div2');
            if (d1) chartContainers.push(d1);
            if (d2) chartContainers.push(d2);
            // If no containers found, fallback to observing the whole page (show legend normally)
            if (chartContainers.length > 0 && legend) {
                const onIntersect = (entries) => {
                    // Show legend if any container is at least partially visible
                    const anyVisible = entries.some(e => e.isIntersecting && e.intersectionRatio > 0.05);
                    // Only show legend if it has content (built) and chart datasets exist
                    const hasItems = document.getElementById('legend-content')?.children?.length > 0;
                    if (anyVisible && hasItems) {
                        legend.style.display = 'block';
                    } else {
                        legend.style.display = 'none';
                    }
                };
                const obs = new IntersectionObserver(onIntersect, { root: null, threshold: [0, 0.05, 0.2] });
                chartContainers.forEach(c => obs.observe(c));
                window._timelineLegendVisibilityObserver = obs;
            }
        }
    } catch (e) { console.warn('Legend visibility observer failed to install:', e); }
});

// Show/hide per-chart overlay legends only when the main navigation is explicitly closed/hidden.
function isMainNavClosed() {
    try {
        const mainNav = document.getElementById('main-nav');
        const body = document.body;
        // If there's no main-nav element, do NOT treat as closed: overlays should remain hidden
        if (!mainNav) return false;
        // If body explicitly hides main-nav (app-level class), treat as closed
        if (body.classList.contains('main-nav-hidden') || body.classList.contains('sidebar-hidden')) return true;
        // If #main-nav has inline display:none or visibility hidden, treat as closed
        const style = window.getComputedStyle(mainNav);
        if (style.display === 'none' || style.visibility === 'hidden') return true;
        // If main-nav has semantic classes that indicate it's collapsed/closed
        if (mainNav.classList.contains('closed') || mainNav.classList.contains('collapsed') || mainNav.getAttribute('aria-hidden') === 'true') return true;
        // If width is very small (collapsed to icons only), consider it closed for overlay purposes
        const w = parseFloat(style.width || '0');
        if (!isNaN(w) && w > 0 && w < 48) return true;
        // Otherwise not closed
        return false;
    } catch (e) { return false; }
}

function updateOverlayLegendVisibility() {
    try {
        const show = isMainNavClosed();
        // Determine which overlay(s) should be visible based on the chart-type toggle
    const selectedToggle = document.querySelector('input[name="toogleChartType"]:checked')?.value || 'div1';
        document.querySelectorAll('.overlay-legend').forEach((el) => {
            // Only show if overlay actually has legend items inside
            const hasItems = el.querySelector('.overlay-legend-content')?.children?.length > 0;
            const overlayFor = (el.getAttribute('data-overlay-for') || '').trim();
            // Decide visibility: nav must be closed, overlay must have items, and overlay must match the selected toggle
            let shouldBeVisible = false;
            if (show && hasItems) {
                if (selectedToggle === 'both') {
                    shouldBeVisible = true;
                } else if (selectedToggle === overlayFor) {
                    shouldBeVisible = true;
                } else {
                    // Selected toggle may be 'div1' or 'div2' - only show matching overlay
                    shouldBeVisible = false;
                }
            }
            if (shouldBeVisible) {
                el.style.display = 'block';
                el.setAttribute('aria-hidden', 'false');
            } else {
                el.style.display = 'none';
                el.setAttribute('aria-hidden', 'true');
            }
        });
        // Also refresh titles in case scope changed but titles haven't been updated yet
        try { if (typeof updateOverlayTitles === 'function') updateOverlayTitles(); } catch (e) { /* ignore */ }
    } catch (e) { /* ignore visibility update errors */ }
}

// Install a MutationObserver to watch for main-nav class/style changes and body class toggles
try {
    if (!window._timelineOverlayNavObserver) {
        const targets = [];
        const mainNav = document.getElementById('main-nav');
        if (mainNav) targets.push(mainNav);
        targets.push(document.body);
        const obs = new MutationObserver((mutations) => {
            // Quick debounce
            clearTimeout(window._overlayNavVisibilityTimer);
            window._overlayNavVisibilityTimer = setTimeout(() => updateOverlayLegendVisibility(), 40);
        });
        targets.forEach((n) => {
            try { obs.observe(n, { attributes: true, attributeFilter: ['class', 'style', 'aria-hidden'] }); } catch (e) { /* ignore */ }
        });
        window._timelineOverlayNavObserver = obs;
    }
} catch (e) { /* ignore */ }

// Storage events may toggle saved collapsed state in navigation code; listen for changes from other windows
window.addEventListener('storage', (ev) => {
    if (!ev.key || ev.key.indexOf('Nav') >= 0 || ev.key.indexOf('standaloneNavCollapsed') >= 0) {
        setTimeout(updateOverlayLegendVisibility, 30);
    }
});

// Do not auto-run visibility update on page init; visibility will be driven
// by the nav MutationObserver and explicit nav-close/open actions.

// Run a guarded initial visibility update shortly after load so overlays appear
// when the page first renders (kept short to allow chart setup).
setTimeout(() => {
    try {
        if (window.updateOverlayLegendVisibility) window.updateOverlayLegendVisibility();
    } catch (e) { /* ignore */ }
}, 120);

// Update overlay titles when scope changes (hash, entity selector, or scope controls)
function updateOverlayTitles() {
    try {
        const titleText = getOverlayTitleText();
        // Debug: log computed title and relevant inputs so we can trace why default appears
        try {
            const hash = window.location.hash || '';
            const ent = document.getElementById('entityId') ? document.getElementById('entityId').value : '<no-entityId>';
            const selScope = (document.getElementById('selectScope') && document.getElementById('selectScope').value) || '<no-selectScope>';
            console.debug('[overlay title debug] computedTitle=', titleText, ' hash=', hash, ' entityId=', ent, ' selectScope=', selScope, ' overlays=', document.querySelectorAll('.overlay-legend').length);
        } catch (e) { /* ignore logging errors */ }
        document.querySelectorAll('.overlay-legend').forEach((ov) => {
            try {
                const t = ov.querySelector('.overlay-legend-title');
                if (t) t.textContent = titleText;
            } catch (e) { /* ignore per-overlay errors */ }
        });
    } catch (e) { /* ignore */ }
}

// Remove duplicate overlays in the hero root: keep only one overlay per data-overlay-for attribute.
function tidyOverlayLegends() {
    try {
        const heroRoot = document.querySelector('.heroTransparent.notdark') || document.querySelector('.heroTransparent') || document.body;
        const overlays = Array.from(heroRoot.querySelectorAll('.overlay-legend'));
        if (overlays.length <= 1) return;
        const seen = new Map();
        overlays.forEach((ov) => {
            const key = ov.getAttribute('data-overlay-for') || '__orphan__';
            if (!seen.has(key)) {
                seen.set(key, ov);
            } else {
                try { ov.remove(); } catch (e) { /* ignore */ }
            }
        });
        // Remove leftover orphans if there are too many (keep at most one orphan)
        const orphanKey = '__orphan__';
        const orphanEls = Array.from(heroRoot.querySelectorAll('.overlay-legend:not([data-overlay-for])'));
        if (orphanEls.length > 1) {
            for (let i = 1; i < orphanEls.length; i++) {
                try { orphanEls[i].remove(); } catch (e) { /* ignore */ }
            }
        }
    } catch (e) { /* ignore */ }
}

// Hash changes indicate scope changes in this app
window.addEventListener('hashchange', () => {
    try { updateOverlayTitles(); } catch (e) { /* ignore */ }
});

// When the entity selector changes, update titles
document.addEventListener('change', (ev) => {
    try {
        const id = ev.target && ev.target.id;
        if (id === 'entityId' || id === 'selectScope') {
            updateOverlayTitles();
        }
    } catch (e) { /* ignore */ }
});


// Helper: position legend next to a target canvas. Also manages observers/listeners
function _positionLegendHelper(legend, targetCanvas, selectedToggle) {
    if (!legend || !targetCanvas) return;

    // Debounced reposition function
    const reposition = () => {
        try {
            const rect = targetCanvas.getBoundingClientRect();
            const lw = legend.offsetWidth || 220;
            const topPos = rect.top + window.scrollY + 20;
            if (window.innerWidth <= 700) {
                legend.style.left = Math.max(8, rect.left + 12 + window.scrollX) + 'px';
                legend.style.top = Math.max(8, rect.top + 12 + window.scrollY) + 'px';
            } else {
                const leftPos = rect.left + window.scrollX - lw - 18;
                let chosenLeft = (leftPos < 8 ? rect.right + 18 + window.scrollX : leftPos);
                // Avoid overlapping the whichLinesHolder controls
                try {
                    const which = document.querySelector('.whichLinesHolder');
                    if (which) {
                        const wRect = which.getBoundingClientRect();
                        const legendRectCandidate = { left: chosenLeft, top: Math.max(12, topPos), right: chosenLeft + lw, bottom: Math.max(12, topPos) + (legend.offsetHeight || 220) };
                        const whichRectAbs = { left: wRect.left + window.scrollX, top: wRect.top + window.scrollY, right: wRect.right + window.scrollX, bottom: wRect.bottom + window.scrollY };
                        const intersects = !(legendRectCandidate.right < whichRectAbs.left || legendRectCandidate.left > whichRectAbs.right || legendRectCandidate.bottom < whichRectAbs.top || legendRectCandidate.top > whichRectAbs.bottom);
                        if (intersects) {
                            // move legend to the right of the canvas instead
                            chosenLeft = rect.right + 18 + window.scrollX;
                        }
                    }
                } catch (e) { /* ignore */ }
                legend.style.left = chosenLeft + 'px';
                legend.style.top = Math.max(12, topPos) + 'px';
            }
            legend.style.position = 'absolute';
            legend.style.right = 'auto';
            legend.style.zIndex = 9999;
        } catch (e) { /* ignore */ }
    };

    // Clean up any previous observers/listeners we created
    try {
        if (window._timelineLegendCleanup) {
            window._timelineLegendCleanup();
        }
    } catch (e) { /* ignore */ }

    // Create a ResizeObserver on the canvas to reposition when it changes
    let ro = null;
    try {
        ro = new ResizeObserver(() => {
            reposition();
        });
        ro.observe(targetCanvas);
    } catch (e) { ro = null; }

    // Debounce helper for scroll/resize
    let timer = null;
    const onScrollOrResize = () => { clearTimeout(timer); timer = setTimeout(reposition, 80); };
    window.addEventListener('scroll', onScrollOrResize, { passive: true });
    window.addEventListener('resize', onScrollOrResize);

    // Store cleanup so next call removes these
    window._timelineLegendCleanup = () => {
        try { if (ro) ro.disconnect(); } catch (e) {}
        try { window.removeEventListener('scroll', onScrollOrResize); } catch (e) {}
        try { window.removeEventListener('resize', onScrollOrResize); } catch (e) {}
        try { clearTimeout(timer); } catch (e) {}
        window._timelineLegendCleanup = null;
    };

    // Initial position
    reposition();
}
</script>
</body>
</html>
